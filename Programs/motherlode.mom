PROGRAM_START
    NOP
    BRB1 GAME_BOOT //Start game at button press
    NOP
    JMP PROGRAM_START
    NOP

GAME_BOOT
    MOV R0 10 //Set player default coordinates
    MOV R1 8
    STR R0 0 //X
    STR R1 1 //Y

    MOV R1 0 //X-index
TOP_ROW_LOOP
    MOV RF 0
    STRVR RF R1
    MOV RF 1
    ADD R1 R1 RF
    MOV RF 20
    CMP R1 RF
    BRZ TOP_ROW_DONE
    NOP
    JMP TOP_ROW_LOOP
    NOP
TOP_ROW_DONE
    MOV RF 1 //Number 0 tile
    MOV R1 x0013 // left on top row
    STRVR RF R1 //Score 0
    MOV R1 x0012 
    STRVR RF R1 //Score 0
    MOV R1 x0011 
    STRVR RF R1 //Score 0
    MOV R1 x0010 
    STRVR RF R1 //Score 0
    
    MOV RF x15 //Peng symbol
    MOV R1 x000F //Where money symbol should be
    STRVR RF R1 //Put money symbol
    
    MOV RF x14	//Drill symbol
    MOV R1 xC  	//screen addres for symbol
    STRVR RF R1	//Put drill icon
    
    MOV RF x2	//1 symbol
    MOV R1 xD  	//screen addres for symbol
    STRVR RF R1	//Put 1 icon
    
    

    MOV R0 1 //Row
    MOV R1 0 //Col
    MOV RE x00FF //For masking
VMEM_FILL_LOOP
    LFSR R2 //Move random number to R2
    AND R2 R2 RE //Only keep one byte of R2
    MOV RF 125 //Start comparing for which tile to place
    CMP R2 RF
    BRN VMEM_FILL_STONE
    NOP
    MOV RF 163 //These numbers are carefully choosen
    CMP R2 RF
    BRN VMEM_FILL_SILVER
    NOP
    MOV RF 189
    CMP R2 RF
    BRN VMEM_FILL_GOLD
    NOP
    MOV RF 202
    CMP R2 RF
    BRN VMEM_FILL_RUBY
    NOP
    MOV R3 x0F //Stone Tile address
    JMP VMEM_FILL_END_LOOP
    NOP

VMEM_FILL_STONE
    MOV R3 x10 //Tile address
    JMP VMEM_FILL_END_LOOP
    NOP
VMEM_FILL_SILVER
    MOV R3 x11 //Tile address
    JMP VMEM_FILL_END_LOOP
    NOP
VMEM_FILL_GOLD
    MOV R3 x12 //Tile address
    JMP VMEM_FILL_END_LOOP
    NOP
VMEM_FILL_RUBY
    MOV R3 x13 //Tile address
    JMP VMEM_FILL_END_LOOP
    NOP

VMEM_FILL_END_LOOP
    MOV RD 8
    LSL R4 R0 RD
    ADD R4 R4 R1 //R4 contains indexing for vmem
    STRVR R3 R4 //Write tile address
    MOV RD 1
    ADD R1 R1 RD
    MOV RD 21
    CMP R1 RD //Check if col has reached 21
    BRZ VMEM_FILL_RST_X
    NOP
    JMP VMEM_FILL_LOOP
    NOP
VMEM_FILL_RST_X
    MOV R1 0 //Reset col
    MOV RD 1
    ADD R0 RD R0 //add one to row
    MOV RD 17
    CMP R0 RD //Check if row is 17
    BRZ PLACE_PLAYER
    NOP
    JMP VMEM_FILL_LOOP
    NOP

PLACE_PLAYER
    MOV R0 x0D //Player down tile
    STRV R0 x070A
    MOV R0 x7
    STR R0 1 // y-pos
    MOV R0 xA
    STR R0 0 //x-pos
    MOV R0 1
    STR R0 3 //Drill level
    MOV R0 0
    STR R0 4 //Score

GAMEPLAY_START

MAIN_LOOP
    MOV RF 0
    BRJU JOY_UP
    NOP
    STR RF 102
    BRJD JOY_DOWN
    NOP
    STR RF 103
    BRJR JOY_RIGHT
    NOP
    STR RF 105
    BRJL JOY_LEFT
    NOP
    STR RF 104
    JMP MAIN_LOOP //Restart loop
    NOP

JOY_UP
    MOV RF 1
    LDA R0 102
    CMP RF R0
    BRZ MAIN_LOOP
    NOP
    STR RF 102

    MOV R0 3
    MOV R4 0
    MOV R5 -1
    JMP MOVE
    NOP
JOY_DOWN
    MOV RF 1
    LDA R0 103
    CMP RF R0
    BRZ MAIN_LOOP
    NOP
    STR RF 103

    MOV R0 2
    MOV R4 0
    MOV R5 1
    JMP MOVE
    NOP
JOY_RIGHT
    MOV RF 1
    LDA R0 105
    CMP RF R0
    BRZ MAIN_LOOP
    NOP
    STR RF 105

    MOV R0 1
    MOV R4 1
    MOV R5 0
    JMP MOVE
    NOP
JOY_LEFT
    MOV RF 1
    LDA R0 104
    CMP RF R0
    BRZ MAIN_LOOP
    NOP
    STR RF 104

    MOV R0 0
    MOV R4 -1
    MOV R5 0
    JMP MOVE
    NOP

MOVE //R4 should contain delta-x, R5 should contain delta-y, R0 should contain direction
    STR R0 2
    LDA R1 0 //X pos
    LDA R2 1 //Y pos
    LDA R6 3 //Drill level

    ADD R7 R1 R4 //New x-pos
    ADD R8 R2 R5 //New y-pos

    MOV RF 20 //Check if too far right
    CMP RF R7
    BRZ NEXT_SCREEN
    NOP
    MOV RF -1 //Check too far left
    CMP RF R7
    BRZ NEXT_SCREEN
    NOP
    MOV RF 0 //Check too far up
    BRZ NEXT_SCREEN
    NOP
    MOV RF 15 //Check too far down
    BRZ NEXT_SCREEN
    NOP
    JMP NO_BORDER_WRAP

NEXT_SCREEN //R2 = Y POS, R1 = X POS FROM EARLIER
    MOV RF 0
    CMP R1 RF
    BRZ Y_BORDER_WRAP //No X-movement
    NOP
    BRN X_WRAP_LEFT // delta X < 0
    NOP
    JMP X_WRAP_RIGHT // delta X > 0
    NOP

Y_BORDER_WRAP
    CMP R2 RF
    BRZ NO_BORDER_WRAP //No Y-movement
    NOP
    BRN Y_WRAP_UP  // delta Y < 0
    NOP
    JMP Y_WRAP_DOWN // delta Y > 0
    NOP

X_WRAP_LEFT
    MOV RF 1000		// Calculate what tile is where we try to move on new screen all according to formula
    LDA RE 10  		 // X coord for room
    LDA RD 11 		 // Y coord for room
    MUL RD RD 8 	 // Y * 8 
    ADD RE RE RD 	 // X + Y*8
    MUL RE RE 280 	 // 280(X + Y*8)
    ADD RF RF RE 	 // 1000 + 280(X + Y *8) , start adress for tiles in new room

    MOV RE 20		 //Calculate tile adress in room according to formula of tile we want to move to
    MOV RD 1		 //Top row is not in the dMem, need to adjust for that
    SUB RD R2 RD
    MUL RE RE RD         //20*Y
    MOV RD 19 	       	 //When wrapping left, new X is 19
    ADD RE RE RD         //20*Y + X
    ADD RB RF RD       	 //Room_adress + 20*Y + X = Tile_adress

    LDAR RF RB		 //New tile in RF
    LDA RE 3  		 //Drill level
    MOV RD x0F		 //Start adress for breakable rocks
    ADD RE RE RD	 //Highest tile that can be broken
    CMP RE RF 		 //Can i breakz?
    BRN TURN 		 //NO BREAK ROCK CANCEL
    NOP
    MOV R5 19		//UPDATE PLAYER X, Y IS SAME
    MOV R6 0
    ADD R6 R6 R2
    	
    JMP CHANGE_SCREEN
    NOP

CHANGE_SCREEN //RF is tile that was broken, RD is start adress for breakable blocks, R1 is OLD player X, R2 is OLD player Y, R5 is new player X, R6 is new player Y, RB is start adress for new room tiles in data
    MOV RE 0 //Before that calculate the new score
    SUB RF RF RD
    CMP RF RE //Check if ground
    BRZ CONT_CHANGE_SCREEN
    NOP
    MOV RE 1
    SUB RF RF RE
    LDA RD 4 //Load score to RD
    LSL RE RE RF
    ADD RD RD RE //New score in RD
    STR RD 4
    MOV RE 4
    LDA RF 3 //Drill level in RF
    CMP RE RF
    BRZ CONT_CHANGE_SCREEN //go back if max drill level
    NOP
    MOV RE 10
    MUL RF RF RE
    CMP RD RF
    BRN CONT_CHANGE_SCREEN //Not enough score to level up
    NOP

    LDA RE 3 //Level up the drill
    MOV RF 1
    ADD RE RE RF
    STR RE 3
   

CONT_CHANGE_SCREEN //Here we want to store the current room to data memory, and load the new room to video memory
    MOV RE 8
    LSL R2 R2 RE
    ADD R2 R2 R1 //CURRENT ADRESS FOR PLAYER IN VMEM
    STRVR R2 RD //OVERWRITE PLAYAH WITH GROUND BEFORE STORING/LOADING FROM MEMORY

    STR R5 0 	//Store new player X
    STR R6 1	//Store new player Y
    
    LDA R4 11	//Current room Y
    LDA R3 10	//Current room X
    MUL R4 R4 RE	  //Calc start adress for current room in dMem
    ADD R4 R4 R3
    MOV R3 280
    ADD R4 R4 R3
    MOV R3 1000
    ADD R4 R3 R3	//It is in R4

    

    MOV RF 0	   //Loop X
    MOV RE 0	   //Loop Y
    MOV RD 1	   //For inc/dec 1

CHANGE_SCREEN_LOOP //Needs RF for loop X, RE for loop Y, R4 for start adress old room, RB start adress new room, RD is inc/dec 1 register, RC is 8 for shifting to adress vMem
    MOV R0 20
    MUL R1 RE R0
    ADD R1 RE RF	//OFFSETT FOR CURRENT TILE IN THE ROOM IN R1
    ADD R3 R1 R4	//ADRESS TO STORE TILE X Y IN DMEM IN R3
    ADD R2 RE RD
    LSL R2 R2 RC
    ADD R2 RF		//ADRESS TO CURRENT TILE IN VMEM IN R2
    LDAVR R5 R2		//Current tile in R5
    STRR R3 R5		//STR CURRENT TILE IN dMEM
    ADD RA RB R1
    LDAR R5 RA		//R5 IS TILE THAT IS NEWLY LOADED
    STRVR R3 R5
    MOV R0 19
    CMP RF R0
    BRZ SCREEN_INC_X
    NOP
    MOV RF 0
    MOV R0 13
    CMP RE R0
    BRZ SCREEN_PLACE_PLAYER
    NOP
    ADD RE RE RD
    JMP CHANGE_SCREEN_LOOP
    NOP
SCREEN_INC_X
    ADD RF RF RD
    JMP CHANGE_SCREEN_LOOP
    NOP

SCREEN_PLACE_PLAYER
    LDA R0 0	//PLAYER X
    LDA R1 1	//PLAYER Y
    MOV R2 8
    LSL R1 R1 R2
    ADD R1 R1 R0
    LDA R3 2	//PLAYER DIRECTION
    MOV R4 0B
    ADD R3 R3 R4
    STRVR R3 R1
    JMP UPDATE_SCORE
    NOP   
	

X_WRAP_RIGHT
    MOV RF 1000		// Calculate what tile is where we try to move on new screen all according to formula
    LDA RE 10  		 // X coord for room
    LDA RD 11 		 // Y coord for room
    MUL RD RD 8 	 // Y * 8 
    ADD RE RE RD 	 // X + Y*8
    MUL RE RE 280 	 // 280(X + Y*8)
    ADD RF RF RE 	 // 1000 + 280(X + Y *8) , start adress for tiles in new room

    MOV RE 20		 //Calculate tile adress in room according to formula of tile we want to move to
    MOV RD 1		 //Top row is not in the dMem, need to adjust for that
    SUB RD R2 RD
    MUL RE RE RD         //20*Y
    MOV RD 0 	       	 //When wrapping RIGHT, new X is 19
    ADD RE RE RD         //20*Y + X
    ADD RB RF RD       	 //Room_adress + 20*Y + X = Tile_adress

    LDAR RF RB		 //New tile in RF
    LDA RE 3  		 //Drill level
    MOV RD x0F		 //Start adress for breakable rocks
    ADD RE RE RD	 //Highest tile that can be broken
    CMP RE RF 		 //Can i breakz?
    BRN TURN 		 //NO BREAK ROCK CANCEL
    NOP
    MOV R5 0		//UPDATE PLAYER X, Y IS SAME
    MOV R6 0
    ADD R6 R6 R2
    JMP CHANGE_SCREEN
    NOP

Y_WRAP_UP
    MOV RF 1000		// Calculate what tile is where we try to move on new screen all according to formula
    LDA RE 10  		 // X coord for room
    LDA RD 11 		 // Y coord for room
    MUL RD RD 8 	 // Y * 8 
    ADD RE RE RD 	 // X + Y*8
    MUL RE RE 280 	 // 280(X + Y*8)
    ADD RF RF RE 	 // 1000 + 280(X + Y *8) , start adress for tiles in new room

    MOV RE 20		 //Calculate tile adress in room according to formula of tile we want to move to
    MOV RD 15 	       	 //When wrapping UP, new Y is 14
    MUL RE RD RE         //20*Y

    ADD RE RE R1         //20*Y + X
    ADD RB RF RD       	 //Room_adress + 20*Y + X = Tile_adress

    LDAR RF RB		 //New tile in RF
    LDA RE 3  		 //Drill level
    MOV RD x0F		 //Start adress for breakable rocks
    ADD RE RE RD	 //Highest tile that can be broken
    CMP RE RF 		 //Can i breakz?
    BRN TURN 		 //NO BREAK ROCK CANCEL
    NOP
    MOV R6 14		//UPDATE PLAYER Y, X IS SAME
    MOV R5 0
    ADD R5 R5 R1
    JMP CHANGE_SCREEN
    NOP

Y_WRAP_DOWN
    MOV RF 1000		// Calculate what tile is where we try to move on new screen all according to formula
    LDA RE 10  		 // X coord for room
    LDA RD 11 		 // Y coord for room
    MUL RD RD 8 	 // Y * 8 
    ADD RE RE RD 	 // X + Y*8
    MUL RE RE 280 	 // 280(X + Y*8)
    ADD RF RF RE 	 // 1000 + 280(X + Y *8) , start adress for tiles in new room

    MOV RE 20		 //Calculate tile adress in room according to formula of tile we want to move to
    MOV RD 1 	       	 //When wrapping DOWN, new Y is 1
    MUL RE RD RE         //20*Y

    ADD RE RE R1         //20*Y + X
    ADD RB RF RD       	 //Room_adress + 20*Y + X = Tile_adress

    LDAR RF RB		 //New tile in RF
    LDA RE 3  		 //Drill level
    MOV RD x0F		 //Start adress for breakable rocks
    ADD RE RE RD	 //Highest tile that can be broken
    CMP RE RF 		 //Can i breakz?
    BRN TURN 		 //NO BREAK ROCK CANCEL
    NOP
    MOV R6 1		//UPDATE PLAYER Y, X IS SAME
    MOV R5 0
    ADD R5 R5 R1
    JMP CHANGE_SCREEN
    NOP


NO_BORDER_WRAP
    MOV RF 8 //No out of bounds, check if can drill/move
    LSL RB R8 RF //Shift new y
    ADD RB RB R7 //Vmem new pos in RB

    LDAVR R9 RB //Tile where player tries to move in R9
    LDA RA 3 //Drill level in RA
    MOV RF x0F
    SUB R9 R9 RF
    CMP RA R9
    BRN TURN
    NOP
    JMP AWARD_SCORE
    NOP
CONT_MOVE
    MOV RF 8
    LSL R3 R2 RF //Shift old y
    ADD R3 R3 R1 //Vmem old pos in R3
    MOV RF x0F
    STRVR RF R3 //Write over old tile

    STR R7 0
    STR R8 1

    MOV RF x0B //Start for player sprites
    ADD RF R0 RF

    STRVR RF RB //Write over new tile

    JMP UPDATE_SCORE
    NOP

TURN //R0 - direction, R1 - x-pos, R2 - y-pos
    MOV RF 8
    LSL R3 R2 RF //Shift up y
    ADD R3 R3 R1 //Vmem pos in R3
    MOV RF x0B //Start for player tiles
    ADD RF R0 RF
    STRVR RF R3 //Write over new tile
    JMP MAIN_LOOP
    NOP

AWARD_SCORE // R9 - GroundTile - 0F DONT FUCK UP REGs FROM MOVE!!!
    MOV RF 0
    CMP R9 RF //Check if ground
    BRZ CONT_MOVE
    NOP
    MOV RF 1
    SUB R9 R9 RF
    LDA RF 4 //Load score to RF
    MOV RE 1
    LSL RE RE R9
    ADD RF RF RE //New score in RF
    STR RF 4
    MOV RE 4
    LDA RD 3 //Drill level in RD
    CMP RE RD
    BRZ CONT_MOVE //go back if max drill level
    NOP
    MOV RE 10
    MUL RD RD RE
    CMP RD RF
    BRN ADD_LEVEL
    NOP
    JMP CONT_MOVE
    NOP

ADD_LEVEL
    LDA RE 3
    MOV RF 1
    ADD RE RE RF
    STR RE 3
    JMP CONT_MOVE
    NOP
    
UPDATE_SCORE
    LDA R0 4 //Score to R0
    JMP GET_BCD
    NOP
BCD_RETURN
    MOV RF 1
    ADD R3 R3 RF //Add one to get to correct number tile
    ADD R4 R4 RF
    ADD R5 R5 RF
    ADD R6 R6 RF

    STRV R3 X10
    STRV R4 X11
    STRV R5 X12
    STRV R6 X13

    LDA RF 3 // LOAD DRILL LVL
    MOV RE 1
    ADD RF RF RE //RF IS NOW TILE ADDERSS
    STRV RF XD // Put drill lvl on D tile 

    JMP MAIN_LOOP
    NOP

GET_BCD //Number to BCD should be in R0, returns BCD digits in R3,R4,R5,R6
    MOV R3 0 //Dest for 1000
    MOV R4 0 //Dest for 100
    MOV R5 0 //Dest for 10
    MOV R6 0 //Dest for 1
    MOV RF 1
THOUSAND
    MOV R1 0 //Loop counter
    MOV R2 1000
THOUSAND_LOOP
    CMP R0 R2
    BRN HUNDRED
    NOP
    SUB R0 R0 R2
    ADD R1 R1 RF
    JMP THOUSAND_LOOP
    NOP
HUNDRED
    ADD R3 R3 R1
    MOV R1 0 //Loop counter
    MOV R2 100
HUNDRED_LOOP
    CMP R0 R2
    BRN TEN
    NOP
    SUB R0 R0 R2
    ADD R1 R1 RF
    JMP HUNDRED_LOOP
    NOP
TEN
    ADD R4 R4 R1
    MOV R1 0 //Loop counter
    MOV R2 10
TEN_LOOP
    CMP R0 R2
    BRN ONE
    NOP
    SUB R0 R0 R2
    ADD R1 R1 RF
    JMP TEN_LOOP
    NOP
ONE
    ADD R5 R5 R1
    ADD R6 R6 R0
    JMP BCD_RETURN
    NOP 
    
